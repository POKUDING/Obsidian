# 1. 프로젝트 생성 / 의존성 추가
## 프로젝트 구성
- Spring Boot 3.x
- JDK 17
- Gradle 빌드
## 의존성 추가
- org.springframework.boot:spring-boot-starter-security
- org.springframework.boot:spring-boot-starter-web
- org.springframework.boot:spring-boot-starter-test
- org.springframework.boot:spring-security-test

### SpringBootWebSecurityConfiguration
자동 설정에 의한 기본 보안 설정 클래스 생성

#### 기본보안 설정의 문제점
- 계정 추가나 권한 추가시 문제점
- 시스템에서 필요로 하는 더 세부적이고 추가적인 보안기능이 필요할 때 문제점
## 자동 설정의 의한 기본 보안 작동
- 서버가 기동되면 스프링 시큐리티의 초기화 작업 및 보안설정이 이루어진다
- **별도의 설정이나 코드를 작성하지 않아도 기본적인 웹 보안 기능이 현재 시스템에 연동되어 작동한다.**
	1. 기본적인 모든 요청에 대하여 인증여부를 검증하고 인증이 승인되어야 자원에 접근이 가능하다.
	2. 인증 방식은 폼 로그인 방식과 httpBasic 로그인 방식을 제공한다.
	3. 인증을 시도할 수 있는 로그인 페이지가 자동적으로 생성되어 렌더링 된다.
	4. 인증 승인이 이루어질 수 있도록 한 개의 계정이 기본적으로 제공된다
		- SecurityProperties 설정 클래스에서 생성
		- username: user
		- password: 랜덤 문자열

>Spring-Security 의존성만 추가만 해주어도 로그인을 해야지 api요청이 가능하다. 로그인을 위해서는 id: user pw: 스프링 실행시 나오는 랜덤 문자열 을 입력해야 한다.

### 자동 설정 파일
```JAVA  
@AutoConfiguration  
@ConditionalOnClass({AuthenticationManager.class})  
@Conditional({MissingAlternativeOrUserPropertiesConfigured.class})  
@ConditionalOnBean({ObjectPostProcessor.class})  
@ConditionalOnMissingBean(  
    value = {AuthenticationManager.class, AuthenticationProvider.class, UserDetailsService.class, AuthenticationManagerResolver.class},  
    type = {"org.springframework.security.oauth2.jwt.JwtDecoder"}  
)  
public class UserDetailsServiceAutoConfiguration {  
    private static final String NOOP_PASSWORD_PREFIX = "{noop}";  
    private static final Pattern PASSWORD_ALGORITHM_PATTERN = Pattern.compile("^\\{.+}.*$");  
    private static final Log logger = LogFactory.getLog(UserDetailsServiceAutoConfiguration.class);  
  
    public UserDetailsServiceAutoConfiguration() {  
    }  
  
    @Bean  
    public InMemoryUserDetailsManager inMemoryUserDetailsManager(SecurityProperties properties, ObjectProvider<PasswordEncoder> passwordEncoder) {  
        SecurityProperties.User user = properties.getUser();  
        List<String> roles = user.getRoles();  
        return new InMemoryUserDetailsManager(new UserDetails[]{User.withUsername(user.getName()).password(this.getOrDeducePassword(user, (PasswordEncoder)passwordEncoder.getIfAvailable())).roles(StringUtils.toStringArray(roles)).build()});  
    }  
  
    private String getOrDeducePassword(SecurityProperties.User user, PasswordEncoder encoder) {  
        String password = user.getPassword();  
        if (user.isPasswordGenerated()) {  
            logger.warn(String.format("%n%nUsing generated security password: %s%n%nThis generated password is for development use only. Your security configuration must be updated before running your application in production.%n", user.getPassword()));  
        }  
  
        return encoder == null && !PASSWORD_ALGORITHM_PATTERN.matcher(password).matches() ? "{noop}" + password : password;  
    }  
  
    static final class MissingAlternativeOrUserPropertiesConfigured extends AnyNestedCondition {  
        MissingAlternativeOrUserPropertiesConfigured() {  
            super(ConfigurationPhase.PARSE_CONFIGURATION);  
        }  
  
        @ConditionalOnProperty(  
            prefix = "spring.security.user",  
            name = {"password"}  
        )  
        static final class PasswordConfigured {  
            PasswordConfigured() {  
            }  
        }  
  
        @ConditionalOnProperty(  
            prefix = "spring.security.user",  
            name = {"name"}  
        )  
        static final class NameConfigured {  
            NameConfigured() {  
            }  
        }  
  
        @ConditionalOnMissingClass({"org.springframework.security.oauth2.client.registration.ClientRegistrationRepository", "org.springframework.security.oauth2.server.resource.introspection.OpaqueTokenIntrospector", "org.springframework.security.saml2.provider.service.registration.RelyingPartyRegistrationRepository"})  
        static final class MissingAlternative {  
            MissingAlternative() {  
            }  
        }  
    }  
}
```
위는 자동 설정 파일의 전체 코드이다 여기서
```JAVA
@Bean  
public InMemoryUserDetailsManager inMemoryUserDetailsManager(SecurityProperties properties, ObjectProvider<PasswordEncoder> passwordEncoder) {  
    SecurityProperties.User user = properties.getUser();  
    List<String> roles = user.getRoles();  
    return new InMemoryUserDetailsManager(new UserDetails[]{User.withUsername(user.getName()).password(this.getOrDeducePassword(user, (PasswordEncoder)passwordEncoder.getIfAvailable())).roles(StringUtils.toStringArray(roles)).build()});  
}
```

이 코드를 보면 새로운 유저를 만들어서 넣어주는 것을 볼 수 있다.
이 새로운 유저가 바로 user이름과 랜덤 pw가 들어가있는 기본 유저인데 이 유저클래스는 다음과 같이 정의되어 있다.

```JAVA
//spring-boot-autoconfigure-3.2.5.jar!\org\springframework\boot\autoconfigure\security\SecurityProperties.class
public static class User {  
    private String name = "user";  
    private String password = UUID.randomUUID().toString();  
    private List<String> roles = new ArrayList();  
    private boolean passwordGenerated = true;  
  
    public User() {  
    }  
  
    public String getName() {  
        return this.name;  
    }  
  
    public void setName(String name) {  
        this.name = name;  
    }  
  
    public String getPassword() {  
        return this.password;  
    }  
  
    public void setPassword(String password) {  
        if (StringUtils.hasLength(password)) {  
            this.passwordGenerated = false;  
            this.password = password;  
        }  
    }  
  
    public List<String> getRoles() {  
        return this.roles;  
    }  
  
    public void setRoles(List<String> roles) {  
        this.roles = new ArrayList(roles);  
    }  
  
    public boolean isPasswordGenerated() {  
        return this.passwordGenerated;  
    }  
}
```
위의 유저 클래스가 생성되며 이름은 user, password 는 UUID로 랜덤하게 생성한는 것을 볼 수 있다.

#### SpringBootWebSecurityConfiguratioin.class
시큐리티에 대한 설정은 어디서 할까? 바로 SpringBootWebSecurityConfiguration.class 이다.
```java 
@Configuration(  
    proxyBeanMethods = false  
)  
@ConditionalOnWebApplication(  
    type = Type.SERVLET  
)  
class SpringBootWebSecurityConfiguration {  
    SpringBootWebSecurityConfiguration() {  
    }  
  
    @Configuration(  
        proxyBeanMethods = false  
    )  
    @ConditionalOnMissingBean(  
        name = {"springSecurityFilterChain"}  
    )  
    @ConditionalOnClass({EnableWebSecurity.class})  
    @EnableWebSecurity  
    static class WebSecurityEnablerConfiguration {  
        WebSecurityEnablerConfiguration() {  
        }  
    }  
  
    @Configuration(  
        proxyBeanMethods = false  
    )  
    @ConditionalOnDefaultWebSecurity  
    static class SecurityFilterChainConfiguration {  
        SecurityFilterChainConfiguration() {  
        }  
  
        @Bean  
        @Order(2147483642)  
        SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {  
            http.authorizeHttpRequests((requests) -> {  
                ((AuthorizeHttpRequestsConfigurer.AuthorizedUrl)requests.anyRequest()).authenticated();  
            });  
            http.formLogin(Customizer.withDefaults());  
            http.httpBasic(Customizer.withDefaults());  
            return (SecurityFilterChain)http.build();  
        }  
    }  
}
```
기본 보안작동 설정은 밑에 있는 **SecurityFilterChainConfiguration** 에서 일어나는데 **@ConditionalOnDefaultWebSecurity** 이 어노테이션에 따라서 기본 보안작동 실행 여부가 결정된다.
**@ConditionalOnDefaultWebSecurity** 어노테이션을 따라서 들어가게 되면 
```JAVA
class DefaultWebSecurityCondition extends AllNestedConditions {  
    DefaultWebSecurityCondition() {  
        super(ConfigurationPhase.REGISTER_BEAN);  
    }  
  
    @ConditionalOnMissingBean({SecurityFilterChain.class})  
    static class Beans {  
        Beans() {  
        }  
    }  
  
    @ConditionalOnClass({SecurityFilterChain.class, HttpSecurity.class})  
    static class Classes {  
        Classes() {  
        }  
    }  
}
```
**DefaultWebSecurityCondition** 클래스가 있고 해당 클래스에서 두 조건이 모두 참이어야만 기본설정이 작동한다.

SpringSecurity 의존성을 추가함으로써 **@ConditionalOnClass({SecurityFilterChain.class, HttpSecurity.class})** 이 조건은 참이된다. 또한 SecurityFilterChain을 빈으로 등록한적이 없으면 **@ConditionalOnMissingBean({SecurityFilterChain.class})** 조건 또한 참이되어 기본 보안 설정이 작동하게 되는 것이다.

결국 두 조건이 참이되면 
```JAVA
@Bean  
@Order(2147483642)  
SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {  
    http.authorizeHttpRequests((requests) -> {  
        ((AuthorizeHttpRequestsConfigurer.AuthorizedUrl)requests.anyRequest()).authenticated();  
    });  
    http.formLogin(Customizer.withDefaults());  
    http.httpBasic(Customizer.withDefaults());  
    return (SecurityFilterChain)http.build();  
}
```
위 구문이 실행되게 되는데 모든 요청에 대해 인가여부를 점검하고 로그인 방식을 formLogin과 httpBasic로그인을 지원하도록 설정된다.
# 2. SecurityBuilder / SecurityConfigurer
## 개념
- **ScurityBuilder** 는 빌더 클래스로서 웹 보안을 구성하는 빈 객체와 설정클래스들을 생성하는 역할을 하며 대표적으로 WebSecurity, HttpSecurity 가 있다.
- **SecurityConfigurer** 는 Http 요청과 관련된 보안처리를 담당하는 필터들을 생성하고 여러 초기화 설정에 관여한다.
- **SecurityBuilder** 는 SercurityConfigurer 를 참조하고 있으며 인증 및 인가 초기화 작업은 SecurityConfigurer 에 의해 진행된다.

#### SecurityBuilder
```JAVA
package org.springframework.security.config.annotation;

public interface SecurityBuilder<O> {  
    O build() throws Exception;  
}
```

#### SecurityConfigurer
```JAVA
package org.springframework.security.config.annotation;  
  
public interface SecurityConfigurer<O, B extends SecurityBuilder<O>> {  
    void init(B builder) throws Exception;  
  
    void configure(B builder) throws Exception;  
}
```
# 3. WebSecurity / HttpSecurity

# 4. DelegatingFilterProxy / FilterChainProxy

# 5. 사용자 정의 보안 설정하기